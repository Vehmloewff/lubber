export default "\n\n;(function() {\n\tconst env = {\"ENV\":\"dev\"}\n\n\tif (!window.Deno) window.Deno = {}\n\t\n\twindow.Deno.env = {\n\t\ttoObject() {\n\t\t\treturn {...env}\n\t\t},\n\t\tget(key) {\n\t\t\treturn env[key]\n\t\t},\n\t\tset(key, value) {\n\t\t\tenv[key] = value\n\t\t},\n\t\tdelete(key) {\n\t\t\tdelete env[key]\n\t\t}\n\t}\n})();\n\n;\n\n(async function(){\n\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/mod.ts\nvar mod_exports = {};\n__export(mod_exports, {\n  Block: () => Block,\n  Button: () => Button,\n  Center: () => Center,\n  Column: () => Column,\n  Container: () => Container,\n  DEFAULT_ANIMATION_DELAY: () => DEFAULT_ANIMATION_DELAY,\n  DEFAULT_ANIMATION_DURATION: () => DEFAULT_ANIMATION_DURATION,\n  ElementComponent: () => ElementComponent,\n  ElementListeners: () => ElementListeners,\n  Flex: () => Flex,\n  FlexItem: () => FlexItem,\n  FormField: () => FormField,\n  Image: () => Image,\n  KeyboardInputArea: () => KeyboardInputArea,\n  Label: () => Label,\n  LifecycleListeners: () => LifecycleListeners,\n  Padding: () => Padding,\n  RenderElement: () => RenderElement,\n  Row: () => Row,\n  SingleChildBlock: () => SingleChildBlock,\n  SingleChildGenerics: () => SingleChildGenerics,\n  SizedBox: () => SizedBox,\n  Stack: () => Stack,\n  StackItem: () => StackItem,\n  Styler: () => Styler,\n  TextField: () => TextField,\n  Transition: () => Transition,\n  WindowListeners: () => WindowListeners,\n  colorDefaults: () => colorDefaults,\n  colorIsColorString: () => colorIsColorString,\n  colorIsDark: () => colorIsDark,\n  colorIsRgba: () => colorIsRgba,\n  darkTheme: () => darkTheme,\n  darken: () => darken,\n  easing: () => easing_exports,\n  getAlpha: () => getAlpha,\n  getRgba: () => getRgba,\n  lightTheme: () => lightTheme,\n  lighten: () => lighten,\n  lowerAlpha: () => lowerAlpha,\n  makeAnimationMounter: () => makeAnimationMounter,\n  makeBlurAnimator: () => makeBlurAnimator,\n  makeComponent: () => makeComponent,\n  makeDimensionProvider: () => makeDimensionProvider,\n  makeElementUser: () => makeElementUser,\n  makeFadeAnimator: () => makeFadeAnimator,\n  makeFlyAnimator: () => makeFlyAnimator,\n  makeGenerics: () => makeGenerics,\n  makeLinearGrad: () => makeLinearGrad,\n  makeMiddlewareAttacher: () => makeMiddlewareAttacher,\n  makeRgb: () => makeRgb,\n  makeScaleAnimator: () => makeScaleAnimator,\n  makeSlideAnimator: () => makeSlideAnimator,\n  mediumize: () => mediumize,\n  parseColor: () => parseColor,\n  parseHex: () => parseHex,\n  parseRgbString: () => parseRgbString,\n  raiseAlpha: () => raiseAlpha,\n  render: () => render,\n  reset: () => reset,\n  setAlpha: () => setAlpha,\n  similarize: () => similarize,\n  stringifyColor: () => stringifyColor,\n  stringifyColorString: () => stringifyColorString,\n  stringifyRgba: () => stringifyRgba,\n  toRems: () => toRems\n});\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/middleware.ts\nfunction makeMiddlewareAttacher(params) {\n  return (internals) => {\n    return {\n      async destroy() {\n        if (params.destroy)\n          await params.destroy();\n        await internals.destroy();\n      },\n      destroyed() {\n        if (params.destroyed)\n          params.destroyed();\n        internals.destroyed();\n      },\n      mounted() {\n        if (params.mounted)\n          params.mounted();\n        internals.mounted();\n      },\n      mount() {\n        if (params.mount)\n          params.mount();\n        const element = internals.mount();\n        if (params.useElement)\n          params.useElement(element);\n        return element;\n      }\n    };\n  };\n}\nvar LifecycleListeners = class {\n  #listeners;\n  constructor(listeners) {\n    this.#listeners = listeners;\n  }\n  attach(internals) {\n    return makeMiddlewareAttacher({\n      mount: () => {\n        if (this.#listeners.onMount)\n          this.#listeners.onMount();\n      },\n      mounted: () => {\n        if (this.#listeners.onMounted)\n          this.#listeners.onMounted();\n      },\n      destroy: async () => {\n        if (this.#listeners.onDestroy)\n          await this.#listeners.onDestroy();\n      },\n      destroyed: () => {\n        if (this.#listeners.onDestroyed)\n          this.#listeners.onDestroyed();\n      }\n    })(internals);\n  }\n};\nfunction makeElementUser(fn) {\n  let stashedElement = null;\n  return {\n    attach: makeMiddlewareAttacher({\n      useElement(element) {\n        stashedElement = element;\n        fn(element);\n      }\n    }),\n    reuse() {\n      if (stashedElement)\n        fn(stashedElement);\n    }\n  };\n}\nvar ElementListeners = class {\n  constructor(listeners) {\n    this.mouseIsDown = false;\n    this.mouseIsOver = false;\n    this.attach = makeElementUser((element) => {\n      element.addEventListener(\"mousedown\", (event) => {\n        if (this.#listeners.onMouseDown)\n          this.#listeners.onMouseDown(event);\n        if (this.#listeners.onPressStart && !this.mouseIsDown)\n          this.#listeners.onPressStart();\n        if (this.#listeners.onPressing && !this.mouseIsDown)\n          this.#listeners.onPressing(true);\n        this.mouseIsDown = true;\n      });\n      element.addEventListener(\"mouseup\", (event) => {\n        if (this.#listeners.onMouseUp)\n          this.#listeners.onMouseUp(event);\n        if (this.#listeners.onPressEnd && this.mouseIsDown)\n          this.#listeners.onPressEnd();\n        if (this.#listeners.onPressed && this.mouseIsDown)\n          this.#listeners.onPressed();\n        if (this.#listeners.onPressing && this.mouseIsDown)\n          this.#listeners.onPressing(false);\n        this.mouseIsDown = false;\n      });\n      element.addEventListener(\"mouseenter\", (event) => {\n        if (this.#listeners.onMouseEnter)\n          this.#listeners.onMouseEnter(event);\n        if (this.#listeners.onHoverStart && !this.mouseIsOver)\n          this.#listeners.onHoverStart();\n        if (this.#listeners.onHovering && !this.mouseIsOver)\n          this.#listeners.onHovering(true);\n        this.mouseIsOver = true;\n      });\n      element.addEventListener(\"mouseleave\", (event) => {\n        if (this.#listeners.onMouseLeave)\n          this.#listeners.onMouseLeave(event);\n        if (this.#listeners.onHoverEnd && this.mouseIsOver)\n          this.#listeners.onHoverEnd();\n        if (this.#listeners.onHovering && this.mouseIsOver)\n          this.#listeners.onHovering(false);\n        this.mouseIsOver = false;\n      });\n    }).attach;\n    this.#listeners = listeners;\n  }\n  #listeners;\n};\nvar Styler = class {\n  constructor(fn) {\n    this.style = null;\n    this.#styleFn = fn;\n  }\n  #styleFn;\n  restyle() {\n    if (this.style)\n      this.#styleFn(this.style);\n  }\n  attach(internals) {\n    return makeElementUser((element) => {\n      this.style = element.style;\n      this.#styleFn(element.style);\n    }).attach(internals);\n  }\n};\nfunction makeGenerics() {\n  let stashedElement = null;\n  const children = [];\n  const childrenElements = [];\n  async function removeChild(index) {\n    if (!children[index])\n      throw new Error(`A child at index ${index} does not exist`);\n    if (stashedElement) {\n      const child = children[index];\n      const childElement = childrenElements[index];\n      await child.$.destroy();\n      stashedElement.removeChild(childElement);\n      childrenElements.splice(index, 1);\n      child.$.destroyed();\n    }\n    return children.splice(index, 1)[0];\n  }\n  function insertChild(index, component) {\n    const insertBeforeIndex = index + 1;\n    const insertBeforeElement = childrenElements[insertBeforeIndex];\n    if (stashedElement) {\n      const childElement = component.$.mount();\n      stashedElement.insertBefore(childElement, insertBeforeElement || null);\n      childrenElements.splice(index, 0, childElement);\n      component.$.mounted();\n    }\n    children.splice(index, 0, component);\n  }\n  function push(...children2) {\n    for (const child of children2)\n      insertChild(children2.length, child);\n  }\n  async function pop() {\n    if (!children.length)\n      return null;\n    const lastChildIndex = children.length - 1;\n    return await removeChild(lastChildIndex);\n  }\n  function unshift(...children2) {\n    for (const child of children2.reverse())\n      insertChild(0, child);\n  }\n  async function shift() {\n    if (!children.length)\n      return null;\n    return await removeChild(0);\n  }\n  async function splice(startIndex, removeCount, ...newChildren) {\n    const removed = [];\n    for (let i = 0; i < removeCount; i++)\n      removed.push(await removeChild(startIndex));\n    for (const child of newChildren.reverse())\n      insertChild(startIndex, child);\n    return removed;\n  }\n  function attach(internals) {\n    return makeMiddlewareAttacher({\n      useElement: (element) => {\n        for (const child of children) {\n          const childElement = child.$.mount();\n          element.appendChild(childElement);\n          childrenElements.push(childElement);\n        }\n        stashedElement = element;\n      },\n      destroy: async () => {\n        for (const child of children)\n          await child.$.destroy();\n      },\n      destroyed: () => {\n        for (const child of children)\n          child.$.destroyed();\n      },\n      mounted: () => {\n        for (const child of children)\n          child.$.mounted();\n      }\n    })(internals);\n  }\n  return { removeChild, insertChild, push, pop, shift, unshift, splice, attach, children, childrenElements };\n}\nvar SingleChildGenerics = class {\n  #generics = makeGenerics();\n  async setChild(child) {\n    if (this.#generics.children.length)\n      await this.#generics.removeChild(0);\n    if (child)\n      this.#generics.insertChild(0, child);\n  }\n  attach(internals) {\n    return this.#generics.attach(internals);\n  }\n};\nvar WindowListeners = class {\n  #listeners;\n  constructor(listeners) {\n    this.#listeners = listeners;\n  }\n  attach(internals) {\n    const resizeListener = () => {\n      if (this.#listeners.onResized)\n        this.#listeners.onResized();\n    };\n    globalThis.window.addEventListener(\"resize\", resizeListener);\n    const lifecycle = new LifecycleListeners({\n      onDestroyed() {\n        globalThis.window.removeEventListener(\"resize\", resizeListener);\n      }\n    });\n    return lifecycle.attach(internals);\n  }\n};\nfunction makeDimensionProvider() {\n  let stashedElement = null;\n  const { attach } = makeElementUser((element) => stashedElement = element);\n  function getWidth() {\n    if (!stashedElement)\n      throw new Error(\"Cannot get width before component has mounted\");\n    return stashedElement.clientWidth;\n  }\n  function getHeight() {\n    if (!stashedElement)\n      throw new Error(\"Cannot get height before component has mounted\");\n    return stashedElement.clientHeight;\n  }\n  return { getWidth, getHeight, attach };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/Component.ts\nvar ElementComponent = class {\n  constructor() {\n    this.htmlElement = document.createElement(\"div\");\n    this.$ = {\n      mount: () => this.htmlElement,\n      mounted: () => {\n      },\n      destroy: () => Promise.resolve(),\n      destroyed: () => {\n      }\n    };\n  }\n};\nfunction makeComponent() {\n  let stashedComponent = null;\n  const middlewareToApply = [];\n  const $3 = {\n    mount() {\n      if (!stashedComponent)\n        throw new Error(\"Element was mounted before `render` was called\");\n      return stashedComponent.mount();\n    },\n    mounted() {\n      if (!stashedComponent)\n        throw new Error(\"Element was mounted before `render` was called\");\n      return stashedComponent.mounted();\n    },\n    async destroy() {\n      if (!stashedComponent)\n        throw new Error(\"Element was destroyed before `render` was called\");\n      return await stashedComponent.destroy();\n    },\n    destroyed() {\n      if (!stashedComponent)\n        throw new Error(\"Element was destroyed before `render` was called\");\n      return stashedComponent.destroyed();\n    }\n  };\n  function render2(component) {\n    let updatedInternals = component.$;\n    while (middlewareToApply.length) {\n      const middleware = middlewareToApply[0];\n      middlewareToApply.shift();\n      updatedInternals = middleware.attach(updatedInternals);\n    }\n    stashedComponent = updatedInternals;\n  }\n  function use(middleware) {\n    if (stashedComponent)\n      throw new Error(\"All middleware must be applied before `render` is called\");\n    middlewareToApply.push(middleware);\n    return middleware;\n  }\n  return { $: $3, render: render2, use };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/Block.ts\nfunction Block() {\n  const { $: $3, render: render2, use } = makeComponent();\n  const view = new ElementComponent();\n  use(\n    new Styler((style) => {\n      style.width = \"100%\";\n      style.height = \"100%\";\n    })\n  );\n  render2(view);\n  return { $: $3 };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/color.ts\nvar colorDefaults = {\n  red: parseHex(`#f44336`),\n  tomato: parseHex(`#ff6347`),\n  pink: parseHex(`#e91e63`),\n  violet: parseHex(`#ee82ee`),\n  purple: parseHex(`#9c27b0`),\n  deepPurple: parseHex(`#673ab7`),\n  indigo: parseHex(`#3f51b5`),\n  blue: parseHex(`#2196f3`),\n  dodgerBlue: parseHex(`#1e90ff`),\n  lightBlue: parseHex(`#87ceeb`),\n  slateBlue: parseHex(`#6a5acd`),\n  cobalt: parseHex(`#0050ef`),\n  cyan: parseHex(`#00bcd4`),\n  aqua: parseHex(`#00ffff`),\n  teal: parseHex(`#009688`),\n  green: parseHex(`#4caf50`),\n  seaGreen: parseHex(`#3cb371`),\n  lightGreen: parseHex(`#8bc34a`),\n  darkGreen: parseHex(`#096347`),\n  lime: parseHex(`#cddc39`),\n  sand: parseHex(`#fdf5e6`),\n  khaki: parseHex(`#f0e68c`),\n  yellow: parseHex(`#ffeb3b`),\n  amber: parseHex(`#ffc107`),\n  orange: parseHex(`#ff9800`),\n  deepOrange: parseHex(`#ff5722`),\n  blueGray: parseHex(`#607d8b`),\n  blueGrey: parseHex(`#607d8b`),\n  brown: parseHex(`#795548`),\n  lightGray: parseHex(`#f1f1f1`),\n  lightGrey: parseHex(`#f1f1f1`),\n  gray: parseHex(`#f1f1f1`),\n  grey: parseHex(`#f1f1f1`),\n  darkGray: parseHex(`#616161`),\n  darkGrey: parseHex(`#616161`),\n  paleRed: parseHex(`#ffdddd`),\n  paleYellow: parseHex(`#ffffcc`),\n  paleGreen: parseHex(`#ddffdd`),\n  paleBlue: parseHex(`#ddffff`),\n  black: parseHex(`#000000`),\n  white: parseHex(`#ffffff`)\n};\nfunction makeLinearGrad(stops, options = {}) {\n  return {\n    type: \"linear-grad\",\n    stops,\n    ...options\n  };\n}\nfunction makeRgb(red, green, blue, alpha) {\n  return [red, green, blue, alpha || 1];\n}\nfunction parseHex(hex) {\n  const hexCharacters = \"a-f\\\\d\";\n  const match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;\n  const match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;\n  const nonHexChars = new RegExp(`[^#${hexCharacters}]`, \"gi\");\n  const validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, \"i\");\n  if (typeof hex !== \"string\" || nonHexChars.test(hex) || !validHexSize.test(hex)) {\n    throw new TypeError(`Invalid hex color: ${hex}`);\n  }\n  hex = hex.replace(/^#/, \"\");\n  let alpha = 1;\n  if (hex.length === 8) {\n    alpha = Number.parseInt(hex.slice(6, 8), 16) / 255;\n    hex = hex.slice(0, 6);\n  }\n  if (hex.length === 4) {\n    alpha = Number.parseInt(hex.slice(3, 4).repeat(2), 16) / 255;\n    hex = hex.slice(0, 3);\n  }\n  if (hex.length === 3) {\n    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n  }\n  const number = Number.parseInt(hex, 16);\n  const red = number >> 16;\n  const green = number >> 8 & 255;\n  const blue = number & 255;\n  return [red, green, blue, alpha];\n}\nfunction parseRgbString(rgbString) {\n  const errorOut = () => {\n    throw new Error(`Invalid rgb string: ${rgbString}`);\n  };\n  const numbers = rgbString.replace(/rgba?/, \"\").trim().slice(1, -1).split(\",\").map((s) => Number(s.trim()));\n  numbers.forEach((num, index) => {\n    if (isNaN(num))\n      errorOut();\n    if (index === 3 && (num > 1 || num < 0))\n      errorOut();\n    else if (num > 255 || num < 0)\n      errorOut();\n  });\n  if (numbers.length < 3 || numbers.length > 4)\n    errorOut();\n  if (numbers.length === 3)\n    numbers.push(1);\n  return numbers;\n}\nfunction parseColor(color) {\n  color = color.trim();\n  if (colorIsColorString(color))\n    return colorDefaults[color];\n  if (color.startsWith(\"#\"))\n    return parseHex(color);\n  if (color.startsWith(\"rgb\"))\n    return parseRgbString(color);\n  if (color.startsWith(\"hsl\"))\n    throw new Error(`HSL colors are not supported: ${color}`);\n  throw new Error(`Invalid color: ${color}`);\n}\nfunction stringifyRgba(rgba) {\n  if (rgba[3] === 1)\n    return `rgb(${rgba[0]}, ${rgba[1]}, ${rgba[2]})`;\n  return `rgb(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3]})`;\n}\nfunction colorIsRgba(color) {\n  if (!Array.isArray(color) || color.length !== 4)\n    return false;\n  for (const num of color) {\n    if (typeof num !== \"number\")\n      return false;\n  }\n  return true;\n}\nfunction colorIsColorString(color) {\n  return !!colorDefaults[color];\n}\nfunction stringifyColorString(color) {\n  return stringifyRgba(colorDefaults[color]);\n}\nfunction stringifyColor(color) {\n  if (colorIsRgba(color))\n    return stringifyRgba(color);\n  if (colorIsColorString(color))\n    return stringifyColorString(color);\n  throw new Error(\"It is not implemented to stringify color type yet\");\n}\nfunction getRgba(color) {\n  if (colorIsRgba(color))\n    return color;\n  if (colorIsColorString(color))\n    return colorDefaults[color];\n  throw new Error(\"Color is to complex to have an RGB inferred from it\");\n}\nfunction lighten(color, amount = 20) {\n  const rgba = getRgba(color);\n  let [r, g2, b3, a2] = rgba;\n  r += amount;\n  g2 += amount;\n  b3 += amount;\n  return [r, g2, b3, a2];\n}\nfunction darken(color, amount = 20) {\n  const rgba = getRgba(color);\n  let [r, g2, b3, a2] = rgba;\n  r -= amount;\n  g2 -= amount;\n  b3 -= amount;\n  return [r, g2, b3, a2];\n}\nfunction mediumize(color, amount = 20) {\n  const rgba = getRgba(color);\n  if (colorIsDark(rgba))\n    return lighten(rgba, amount);\n  return darken(rgba, amount);\n}\nfunction similarize(color, amount = 20) {\n  const rgba = getRgba(color);\n  if (colorIsDark(rgba))\n    return darken(rgba, amount);\n  return lighten(rgba, amount);\n}\nfunction lowerAlpha(color, amount = 0.1) {\n  const rgba = getRgba(color);\n  return setAlpha(rgba, getAlpha(rgba) - amount);\n}\nfunction raiseAlpha(color, amount = 0.1) {\n  const rgba = getRgba(color);\n  return setAlpha(rgba, getAlpha(rgba) + amount);\n}\nfunction colorIsDark(color) {\n  const rgba = getRgba(color);\n  const [r, g2, b3] = rgba;\n  const hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g2 * g2) + 0.114 * (b3 * b3));\n  return hsp < 127.5;\n}\nfunction setAlpha(color, alpha) {\n  const rgba = getRgba(color);\n  if (alpha > 1)\n    alpha = 1;\n  else if (alpha < 0)\n    alpha = 0;\n  return [rgba[0], rgba[1], rgba[2], alpha];\n}\nfunction getAlpha(color) {\n  const rgba = getRgba(color);\n  return rgba[3];\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/style.ts\nfunction toRems(value) {\n  return `${value / 16}rem`;\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/SingleChildBlock.ts\nfunction SingleChildBlock(props = {}) {\n  const { $: $3, render: render2, use } = makeComponent();\n  const generics = use(new SingleChildGenerics());\n  const view = Block();\n  render2(view);\n  if (props.child)\n    generics.setChild(props.child);\n  function setChild(child) {\n    generics.setChild(child);\n  }\n  return { $: $3, setChild };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/Container.ts\nfunction Container(props = {}) {\n  const { $: $3, render: render2, use } = makeComponent();\n  const styler = use(\n    new Styler((style) => {\n      style.display = \"flex\";\n      style.alignItems = \"start\";\n      style.backgroundColor = stringifyColor(color);\n      style.borderRadius = toRems(borderRadius);\n      style.borderColor = stringifyColor(borderColor);\n      style.borderWidth = toRems(borderWidth);\n      style.borderStyle = borderStyle;\n      const transitionStrings = [];\n      for (const [key, value] of transitions) {\n        transitionStrings.push(`${key} ${value}ms`);\n      }\n      style.transitionTimingFunction = \"cubic-bezier(0.4, 0, 0.2, 1)\";\n      style.transition = transitionStrings.join(\", \");\n      if (ringColor) {\n        style.boxShadow = `0px 0px 0px ${toRems(ringWidth)} ${stringifyColor(ringColor)}`;\n      } else\n        style.boxShadow = \"\";\n      style.cursor = cursor;\n      if (filters.length)\n        style.filter = filters.join(\" \");\n      else\n        style.filter = \"\";\n      if (backdropFilters.length)\n        style.backdropFilter = backdropFilters.join(\" \");\n      else\n        style.backdropFilter = \"\";\n      style.overflow = clip ? \"hidden\" : \"\";\n    })\n  );\n  const view = SingleChildBlock({ child: props.child });\n  render2(view);\n  let color = props.color ?? [0, 0, 0, 0];\n  let borderRadius = props.borderRadius ?? 0;\n  let borderColor = props.borderColor ?? [0, 0, 0, 1];\n  let borderWidth = props.borderWidth ?? 0;\n  let borderStyle = props.borderStyle ?? \"solid\";\n  let ringColor = props.ringColor ?? null;\n  let ringWidth = props.ringWidth ?? 0;\n  let cursor = props.cursor ?? \"default\";\n  let filters = props.filters ?? [];\n  let backdropFilters = props.backdropFilters ?? [];\n  let clip = props.clip ?? false;\n  const transitions = /* @__PURE__ */ new Map();\n  function setColor(newColor) {\n    color = newColor;\n    styler.restyle();\n  }\n  function setBorderRadius(newBorderRadius) {\n    borderRadius = newBorderRadius;\n    styler.restyle();\n  }\n  function setBorder(newColor, newWidth) {\n    borderColor = newColor;\n    borderWidth = newWidth;\n    styler.restyle();\n  }\n  function setBorderStyle(newStyle) {\n    borderStyle = newStyle;\n    styler.restyle();\n  }\n  function setRing(newColor, newWidth = 3) {\n    ringColor = newColor;\n    ringWidth = newWidth;\n    styler.restyle();\n  }\n  function setCursor(newCursor) {\n    cursor = newCursor;\n    styler.restyle();\n  }\n  function setFilters(newFilters) {\n    filters = newFilters;\n    styler.restyle();\n  }\n  function setBackdropFilters(newBackdropFilters) {\n    backdropFilters = newBackdropFilters;\n    styler.restyle();\n  }\n  function setClip(shouldClip) {\n    clip = shouldClip;\n    styler.restyle();\n  }\n  function setChild(child) {\n    view.setChild(child);\n  }\n  return {\n    $: $3,\n    setColor,\n    setBorderRadius,\n    setBorder,\n    setBorderStyle,\n    setRing,\n    setCursor,\n    setFilters,\n    setBackdropFilters,\n    setClip,\n    setChild\n  };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/Label.ts\nfunction Label(text, props = {}) {\n  const { $: $3, render: render2, use } = makeComponent();\n  const element = new ElementComponent();\n  let color = props.color ?? [0, 0, 0, 1];\n  let underline = props.underline ?? false;\n  let italic = props.italic ?? false;\n  let bold = props.bold ?? false;\n  let fontSize = props.fontSize ?? 16;\n  const transitions = /* @__PURE__ */ new Map();\n  if (props.transitionColors) {\n    transitions.set(\"background-color\", 150);\n    transitions.set(\"border-color\", 150);\n  }\n  const styler = use(\n    new Styler((style) => {\n      style.fontFamily = '\"Source Sans Pro\", sans-serif';\n      style.userSelect = \"none\";\n      style.whiteSpace = \"nowrap\";\n      style.color = stringifyColor(color);\n      style.textDecoration = underline ? \"underline\" : \"none\";\n      style.fontStyle = italic ? \"italic\" : \"normal\";\n      style.fontWeight = bold ? \"700\" : \"400\";\n      style.fontSize = toRems(fontSize);\n      const transitions2 = [];\n      for (const [key, value] of transitions2) {\n        transitions2.push(`${key} ${value}ms`);\n      }\n      style.transitionTimingFunction = \"cubic-bezier(0.4, 0, 0.2, 1)\";\n      style.transition = transitions2.join(\", \");\n    })\n  );\n  if (text) {\n    element.htmlElement.textContent = text;\n  }\n  render2(element);\n  function setText(newText) {\n    element.htmlElement.textContent = newText;\n  }\n  function setColor(newColor) {\n    color = newColor;\n    styler.restyle();\n  }\n  function setUnderline(shouldUnderline) {\n    underline = shouldUnderline;\n    styler.restyle();\n  }\n  function setItalic(shouldItalicize) {\n    italic = shouldItalicize;\n    styler.restyle();\n  }\n  function setBold(shouldBold) {\n    bold = shouldBold;\n    styler.restyle();\n  }\n  function setFontSize(newFontSize) {\n    fontSize = newFontSize;\n    styler.restyle();\n  }\n  return { $: $3, setText, setColor, setUnderline, setItalic, setBold, setFontSize };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/Padding.ts\nfunction Padding(props) {\n  const { $: $3, render: render2, use } = makeComponent();\n  const view = SingleChildBlock({ child: props.child });\n  render2(view);\n  let paddingTop = props.paddingTop ?? props.paddingY ?? props.padding ?? 0;\n  let paddingLeft = props.paddingLeft ?? props.paddingX ?? props.padding ?? 0;\n  let paddingRight = props.paddingRight ?? props.paddingX ?? props.padding ?? 0;\n  let paddingBottom = props.paddingBottom ?? props.paddingY ?? props.padding ?? 0;\n  const styler = use(\n    new Styler((style) => {\n      style.paddingTop = toRems(paddingTop);\n      style.paddingLeft = toRems(paddingLeft);\n      style.paddingRight = toRems(paddingRight);\n      style.paddingBottom = toRems(paddingBottom);\n    })\n  );\n  function setPaddingTop(newPaddingTop) {\n    paddingTop = newPaddingTop;\n    styler.restyle();\n  }\n  function setPaddingLeft(newPaddingLeft) {\n    paddingLeft = newPaddingLeft;\n    styler.restyle();\n  }\n  function setPaddingBottom(newPaddingBottom) {\n    paddingBottom = newPaddingBottom;\n    styler.restyle();\n  }\n  function setPaddingRight(newPaddingRight) {\n    paddingRight = newPaddingRight;\n    styler.restyle();\n  }\n  function setPaddingX(newPaddingX) {\n    paddingRight = newPaddingX;\n    paddingLeft = newPaddingX;\n    styler.restyle();\n  }\n  function setPaddingY(newPaddingY) {\n    paddingTop = newPaddingY;\n    paddingBottom = newPaddingY;\n    styler.restyle();\n  }\n  function setPadding(newPadding) {\n    setPaddingY(newPadding);\n    setPaddingX(newPadding);\n  }\n  function setChild(child) {\n    view.setChild(child);\n  }\n  return { $: $3, setPaddingTop, setPaddingRight, setPaddingBottom, setPaddingLeft, setPaddingX, setPaddingY, setPadding, setChild };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/Button.ts\nfunction Button(text, props = {}) {\n  const { $: $3, render: render2, use } = makeComponent();\n  use(\n    new ElementListeners({\n      onPressed() {\n        if (props.onPressed)\n          props.onPressed();\n      },\n      onHovering(isHovering) {\n        currentlyHovering = isHovering;\n        updateStyles();\n      },\n      onPressing(isPressing) {\n        currentlyPressing = isPressing;\n        updateStyles();\n      }\n    })\n  );\n  const updateStyles = () => {\n    view.setColor(computeColor());\n    label.setColor(props.primary ? \"white\" : \"black\");\n    if (currentlyPressing)\n      view.setRing(props.primary ? setAlpha(\"blue\", 0.3) : setAlpha(\"black\", 0.05), 3);\n    else\n      view.setRing(null);\n  };\n  let currentlyPressing = false;\n  let currentlyHovering = false;\n  const label = Label(text, { bold: true });\n  const view = Container({\n    child: Padding({ paddingX: 10, paddingY: 2 }),\n    borderRadius: 4,\n    cursor: \"pointer\"\n  });\n  function computeColor() {\n    if (props.primary) {\n      if (currentlyHovering)\n        return setAlpha(\"blue\", 0.9);\n      return \"blue\";\n    }\n    if (currentlyHovering)\n      return setAlpha(\"black\", 0.15);\n    return setAlpha(\"black\", 0.1);\n  }\n  render2(view);\n  function setText(newText) {\n    label.setText(newText);\n  }\n  return { $: $3, setText };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/Compress.ts\nfunction Compress(props = {}) {\n  const { $: $3, render: render2, use } = makeComponent();\n  const generics = use(new SingleChildGenerics());\n  render2(new ElementComponent());\n  if (props.child)\n    generics.setChild(props.child);\n  function setChild(child) {\n    generics.setChild(child);\n  }\n  return { $: $3, setChild };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/Center.ts\nfunction Center(props = {}) {\n  const { $: $3, render: render2, use } = makeComponent();\n  use(\n    new Styler((style) => {\n      style.flexGrow = \"1\";\n      style.flexBasis = \"0\";\n      style.display = \"flex\";\n      style.alignItems = \"center\";\n      style.justifyContent = \"center\";\n    })\n  );\n  const compressor = Compress({ child: props.child });\n  render2(Container({ child: compressor }));\n  function setChild(child) {\n    compressor.setChild(child);\n  }\n  return { $: $3, setChild };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/Flex.ts\nfunction Flex(direction, props) {\n  const { $: $3, render: render2, use } = makeComponent();\n  const styler = use(\n    new Styler((style) => {\n      style.display = \"flex\";\n      style.flexDirection = direction;\n      style.gap = toRems(gap);\n      style.alignItems = align;\n      style.justifyContent = justify;\n    })\n  );\n  const generics = use(makeGenerics());\n  render2(Block());\n  let gap = props.gap ?? 0;\n  let align = props.align ?? \"stretch\";\n  let justify = props.justify ?? \"start\";\n  generics.push(...props.children);\n  function setDirection(newDirection) {\n    direction = newDirection;\n    styler.restyle();\n  }\n  function setGap(newGap) {\n    gap = newGap;\n    styler.restyle();\n  }\n  function setAlign(newAlign) {\n    align = newAlign;\n    styler.restyle();\n  }\n  function setJustify(newJustify) {\n    justify = newJustify;\n    styler.restyle();\n  }\n  return { $: $3, setDirection, setGap, setAlign, setJustify, ...generics };\n}\nfunction FlexItem(props) {\n  const { $: $3, render: render2, use } = makeComponent();\n  const generics = use(new SingleChildGenerics());\n  const styler = use(\n    new Styler((style) => {\n      style.flexBasis = \"0\";\n      style.flexGrow = `${expansionRate === true ? 1 : expansionRate === false ? 0 : expansionRate}`;\n      style.flexShrink = shrink ? \"1\" : \"0\";\n    })\n  );\n  render2(new ElementComponent());\n  let expansionRate = props.expand ?? false;\n  let shrink = props.shrink ?? false;\n  function setChild(child) {\n    generics.setChild(child);\n  }\n  function setShrink(shouldShrink = true) {\n    shrink = shouldShrink;\n    styler.restyle();\n  }\n  function setExpand(newExpansion) {\n    expansionRate = newExpansion;\n    styler.restyle();\n  }\n  return { $: $3, setChild, setShrink, setExpand };\n}\nfunction Row(props) {\n  const { setDirection: _2, ...keys } = Flex(\"row\", props);\n  return keys;\n}\nfunction Column(props) {\n  const { setDirection: _2, ...keys } = Flex(\"column\", props);\n  return keys;\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/FormInput.ts\nvar FormField = class {\n  constructor() {\n    this.#changeEmitter = createEmitter();\n    this.#label = new Label().fontSize(14).bold().color(setAlpha(\"black\", 0.3));\n    this.#view = new Column().gap(2).child(this.#label);\n    this.$ = this.#view.$;\n    this.#currentLabel = \"Label\";\n    this.#label.text(this.#currentLabel);\n  }\n  #changeEmitter;\n  #label;\n  #view;\n  #currentLabel;\n  label(label) {\n    this.#label.text(label);\n    return this;\n  }\n  field(field) {\n    this.#view.child(field);\n    return this;\n  }\n  onChange(fn) {\n    this.#changeEmitter.on(fn);\n    return this;\n  }\n};\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/Image.ts\nfunction Image(url, props = {}) {\n  const { $: $3, render: render2, use } = makeComponent();\n  let element = null;\n  let img = null;\n  let fit = props.fit || \"scale_down\";\n  let position = props.position || \"top_left\";\n  use(makeElementUser((e) => element = e));\n  use(\n    new LifecycleListeners({\n      onMounted() {\n        setUrl(url);\n      }\n    })\n  );\n  render2(Block());\n  function styleImg() {\n    if (!img)\n      throw new Error(\"Cannot style img because it isn't defined\");\n    img.style.objectFit = fit.replace(\"_\", \"-\");\n    img.style.position = position.replace(\"_\", \" \");\n    img.style.width = \"100%\";\n    img.style.height = \"100%\";\n  }\n  function createImg() {\n    if (!element)\n      throw new Error(\"Cannot create img because the component has not mounted yet\");\n    img = document.createElement(\"img\");\n    img.draggable = false;\n    img.style.userSelect = \"none\";\n    img.addEventListener(\"load\", () => {\n      if (props.onLoadingDone)\n        props.onLoadingDone();\n    });\n    styleImg();\n    element.appendChild(img);\n    return img;\n  }\n  function setUrl(newUrl) {\n    if (!element) {\n      if (newUrl)\n        url = newUrl;\n      return;\n    }\n    if (!newUrl) {\n      if (img)\n        img.remove();\n      return;\n    }\n    if (!img)\n      img = createImg();\n    img.src = newUrl;\n  }\n  function setFit(newFit) {\n    fit = newFit;\n    styleImg();\n  }\n  function setPosition(newPosition) {\n    position = newPosition;\n    styleImg();\n  }\n  return { $: $3, setUrl, setFit, setPosition };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/KeyboardInputArea.ts\nvar KeyboardInputArea = class {\n  constructor() {\n    this.#changeEmitter = createEmitter();\n    this.#focusEmitter = createEmitter();\n    this.#blurEmitter = createEmitter();\n    this.#lifecycle = useLifecycle();\n    this.#view = new SingleChildBlock();\n    this.#inputElement = document.createElement(\"textarea\");\n    this.$ = this.#view.$.connect(this.#lifecycle);\n    this.#currentAllowNewlines = false;\n    this.#inputElement.style.width = \"100%\";\n    this.#inputElement.style.height = \"100%\";\n    this.#inputElement.style.outline = \"none\";\n    this.#inputElement.style.padding = \"0\";\n    this.#inputElement.style.border = \"none\";\n    this.#inputElement.style.background = \"rgba(0, 0, 0, 0)\";\n    this.#inputElement.style.resize = \"none\";\n    this.#turnWrappingOff();\n    this.#inputElement.addEventListener(\"keydown\", (event) => {\n      if (event.key === \"Enter\" || event.key === \"Return\") {\n        if (!this.#currentAllowNewlines)\n          event.preventDefault();\n      }\n    });\n    this.#inputElement.addEventListener(\"change\", () => {\n      this.#changeEmitter.fire(this.#inputElement.value);\n    });\n    this.#inputElement.addEventListener(\"focus\", () => {\n      this.#focusEmitter.fire();\n    });\n    this.#inputElement.addEventListener(\"blur\", () => {\n      this.#blurEmitter.fire();\n    });\n    this.#lifecycle.onMount(() => {\n      this.$.element.appendChild(this.#inputElement);\n    });\n  }\n  #changeEmitter;\n  #focusEmitter;\n  #blurEmitter;\n  #lifecycle;\n  #view;\n  #inputElement;\n  #currentAllowNewlines;\n  allowNewlines(allowNewlines = true) {\n    this.#currentAllowNewlines = allowNewlines;\n    return this;\n  }\n  #turnWrappingOff() {\n    this.#inputElement.style.whiteSpace = \"pre\";\n  }\n  #turnWrappingOn() {\n    this.#inputElement.style.whiteSpace = \"pre-wrap\";\n  }\n  allowWrapping(allowWrapping = true) {\n    if (allowWrapping)\n      this.#turnWrappingOn();\n    else\n      this.#turnWrappingOff();\n    return this;\n  }\n  onChange(fn) {\n    this.#changeEmitter.on(fn);\n    return this;\n  }\n  onBlur(fn) {\n    this.#blurEmitter.on(fn);\n    return this;\n  }\n  onFocus(fn) {\n    this.#focusEmitter.on(fn);\n    return this;\n  }\n  value(value) {\n    this.#inputElement.value = value;\n    return this;\n  }\n  focus() {\n    this.#inputElement.focus();\n    return this;\n  }\n  blur() {\n    this.#inputElement.blur();\n    return this;\n  }\n};\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/RenderElement.ts\nfunction RenderElement(props) {\n  const { $: $3, render: render2, use } = makeComponent();\n  use(makeElementUser((element) => element.appendChild(props.element)));\n  use(\n    new LifecycleListeners({\n      onDestroy() {\n        if (props.onDestroy)\n          props.onDestroy();\n      }\n    })\n  );\n  render2(Block());\n  return { $: $3 };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/SizedBox.ts\nfunction SizedBox(props = {}) {\n  const { $: $3, render: render2, use } = makeComponent();\n  let width = props.width ?? null;\n  let height = props.height ?? null;\n  const generics = use(new SingleChildGenerics());\n  const styler = use(\n    new Styler((style) => {\n      if (width === null)\n        style.width = \"100%\";\n      else\n        style.width = toRems(width);\n      if (height === null)\n        style.height = \"100%\";\n      else\n        style.height = toRems(height);\n    })\n  );\n  render2(new ElementComponent());\n  generics.setChild(props.child || null);\n  function setHeight(newHeight) {\n    height = newHeight;\n    styler.restyle();\n  }\n  function setWidth(newWidth) {\n    width = newWidth;\n    styler.restyle();\n  }\n  function setChild(child) {\n    generics.setChild(child);\n  }\n  return { $: $3, setHeight, setWidth, setChild };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/Stack.ts\nfunction Stack(props) {\n  const { $: $3, render: render2, use } = makeComponent();\n  use(\n    new Styler((style) => {\n      style.position = \"relative\";\n    })\n  );\n  const generics = use(makeGenerics());\n  generics.push(...props.children);\n  render2(Block());\n  return { $: $3, ...generics };\n}\nfunction StackItem(props) {\n  const { $: $3, render: render2, use } = makeComponent();\n  let top = props.top ?? props.inset ?? null;\n  let right = props.right ?? props.inset ?? null;\n  let bottom = props.bottom ?? props.inset ?? null;\n  let left = props.left ?? props.inset ?? null;\n  const styler = use(\n    new Styler((style) => {\n      style.position = \"absolute\";\n      style.top = top !== null ? toRems(top) : \"\";\n      style.right = right !== null ? toRems(right) : \"\";\n      style.bottom = bottom !== null ? toRems(bottom) : \"\";\n      style.left = left !== null ? toRems(left) : \"\";\n    })\n  );\n  const generics = use(new SingleChildGenerics());\n  const block = new ElementComponent();\n  render2(block);\n  generics.setChild(props.child);\n  function setTop(newTop) {\n    top = newTop;\n    styler.restyle();\n  }\n  function setRight(newRight) {\n    right = newRight;\n    styler.restyle();\n  }\n  function setBottom(newBottom) {\n    bottom = newBottom;\n    styler.restyle();\n  }\n  function setLeft(newLeft) {\n    left = newLeft;\n    styler.restyle();\n  }\n  function setChild(child) {\n    generics.setChild(child);\n  }\n  return { $: $3, setTop, setRight, setBottom, setLeft, setChild };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/TextField.ts\nvar TextField = class {\n  constructor() {\n    this.#inputOutlet = new Padding().paddingY(2).paddingX(10);\n    this.#container = new Container().borderRadius(6).border(\"blue\", 2).cursor(\"text\").child(this.#inputOutlet);\n    this.#view = new SizedBox().child(this.#container);\n    this.#isFocused = false;\n    this.#isShowingPlaceholder = false;\n    this.$ = this.#view.$;\n    this.#showPlaceholder();\n  }\n  #inputOutlet;\n  #container;\n  #view;\n  #isFocused;\n  #isShowingPlaceholder;\n  setInput(input, height = 32) {\n    this.#inputOutlet.child(\n      input.onChange((value) => this.#handleChange(value)).onFocus(() => {\n        this.#isFocused = true;\n        this.#applyLoudness();\n      }).onBlur(() => {\n        this.#isFocused = false;\n        this.#removeLoudness();\n      })\n    );\n    this.#view.height(height);\n    return this;\n  }\n  #removeLoudness() {\n    this.#container.ring(null);\n  }\n  #applyLoudness() {\n    this.#container.ring(setAlpha(\"blue\", 0.3), 4);\n  }\n  #handleChange(value) {\n    if (!value.length && !this.#isShowingPlaceholder)\n      this.#showPlaceholder();\n    if (value.length && this.#isShowingPlaceholder)\n      this.#hidePlaceholder();\n  }\n  #showPlaceholder() {\n    this.#isShowingPlaceholder = true;\n  }\n  #hidePlaceholder() {\n    this.#isShowingPlaceholder = false;\n  }\n};\n\n// resolve:https://esm.sh/stable/svelte@3.59.1/deno/transition.js\nvar __global$ = globalThis || (typeof window !== \"undefined\" ? window : self);\nfunction O() {\n}\nvar x = (t) => t;\nfunction C(t) {\n  return t();\n}\nfunction I(t) {\n  t.forEach(C);\n}\nfunction w(t) {\n  return typeof t == \"function\";\n}\nfunction N(t) {\n  return Object.keys(t).length === 0;\n}\nfunction v(t) {\n  let e = typeof t == \"string\" && t.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n  return e ? [parseFloat(e[1]), e[2] || \"px\"] : [t, \"px\"];\n}\nvar A = typeof document < \"u\" ? window : typeof globalThis < \"u\" ? globalThis : __global$;\nvar b = class {\n  constructor(e) {\n    this.options = e, this._listeners = \"WeakMap\" in A ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(e, i) {\n    return this._listeners.set(e, i), this._getObserver().observe(e, this.options), () => {\n      this._listeners.delete(e), this._observer.unobserve(e);\n    };\n  }\n  _getObserver() {\n    var e;\n    return (e = this._observer) !== null && e !== void 0 ? e : this._observer = new ResizeObserver((i) => {\n      var n;\n      for (let o2 of i)\n        b.entries.set(o2.target, o2), (n = this._listeners.get(o2.target)) === null || n === void 0 || n(o2);\n    });\n  }\n};\nb.entries = \"WeakMap\" in A ? /* @__PURE__ */ new WeakMap() : void 0;\nvar S = [];\nfunction P(t) {\n  let e = [], i = [];\n  S.forEach((n) => t.indexOf(n) === -1 ? e.push(n) : i.push(n)), i.forEach((n) => n()), S = e;\n}\nvar L = [\"allowfullscreen\", \"allowpaymentrequest\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"defer\", \"disabled\", \"formnovalidate\", \"hidden\", \"inert\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"selected\"];\nvar z = /* @__PURE__ */ new Set([...L]);\nfunction R(t, e) {\n  let i = t.$$;\n  i.fragment !== null && (P(i.after_update), I(i.on_destroy), i.fragment && i.fragment.d(e), i.on_destroy = i.fragment = null, i.ctx = []);\n}\nvar B;\ntypeof HTMLElement == \"function\" && (B = class extends HTMLElement {\n  constructor() {\n    super(), this.attachShadow({ mode: \"open\" });\n  }\n  connectedCallback() {\n    let { on_mount: t } = this.$$;\n    this.$$.on_disconnect = t.map(C).filter(w);\n    for (let e in this.$$.slotted)\n      this.appendChild(this.$$.slotted[e]);\n  }\n  attributeChangedCallback(t, e, i) {\n    this[t] = i;\n  }\n  disconnectedCallback() {\n    I(this.$$.on_disconnect);\n  }\n  $destroy() {\n    R(this, 1), this.$destroy = O;\n  }\n  $on(t, e) {\n    if (!w(e))\n      return O;\n    let i = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);\n    return i.push(e), () => {\n      let n = i.indexOf(e);\n      n !== -1 && i.splice(n, 1);\n    };\n  }\n  $set(t) {\n    this.$$set && !N(t) && (this.$$.skip_bound = true, this.$$set(t), this.$$.skip_bound = false);\n  }\n});\nfunction E(t) {\n  return t < 0.5 ? 4 * t * t * t : 0.5 * Math.pow(2 * t - 2, 3) + 1;\n}\nfunction $(t) {\n  let e = t - 1;\n  return e * e * e + 1;\n}\nfunction J(t, { delay: e = 0, duration: i = 400, easing: n = E, amount: o2 = 5, opacity: r = 0 } = {}) {\n  let l2 = getComputedStyle(t), s = +l2.opacity, a2 = l2.filter === \"none\" ? \"\" : l2.filter, f2 = s * (1 - r), [c2, u2] = v(o2);\n  return { delay: e, duration: i, easing: n, css: (_2, h) => `opacity: ${s - f2 * h}; filter: ${a2} blur(${h * c2}${u2});` };\n}\nfunction K(t, { delay: e = 0, duration: i = 400, easing: n = x } = {}) {\n  let o2 = +getComputedStyle(t).opacity;\n  return { delay: e, duration: i, easing: n, css: (r) => `opacity: ${r * o2}` };\n}\nfunction Q(t, { delay: e = 0, duration: i = 400, easing: n = $, x: o2 = 0, y: r = 0, opacity: l2 = 0 } = {}) {\n  let s = getComputedStyle(t), a2 = +s.opacity, f2 = s.transform === \"none\" ? \"\" : s.transform, c2 = a2 * (1 - l2), [u2, _2] = v(o2), [h, p] = v(r);\n  return { delay: e, duration: i, easing: n, css: (m2, y2) => `\n\t\t\ttransform: ${f2} translate(${(1 - m2) * u2}${_2}, ${(1 - m2) * h}${p});\n\t\t\topacity: ${a2 - c2 * y2}` };\n}\nfunction Z(t, { delay: e = 0, duration: i = 400, easing: n = $, axis: o2 = \"y\" } = {}) {\n  let r = getComputedStyle(t), l2 = +r.opacity, s = o2 === \"y\" ? \"height\" : \"width\", a2 = parseFloat(r[s]), f2 = o2 === \"y\" ? [\"top\", \"bottom\"] : [\"left\", \"right\"], c2 = f2.map((d2) => `${d2[0].toUpperCase()}${d2.slice(1)}`), u2 = parseFloat(r[`padding${c2[0]}`]), _2 = parseFloat(r[`padding${c2[1]}`]), h = parseFloat(r[`margin${c2[0]}`]), p = parseFloat(r[`margin${c2[1]}`]), m2 = parseFloat(r[`border${c2[0]}Width`]), y2 = parseFloat(r[`border${c2[1]}Width`]);\n  return { delay: e, duration: i, easing: n, css: (d2) => `overflow: hidden;opacity: ${Math.min(d2 * 20, 1) * l2};${s}: ${d2 * a2}px;padding-${f2[0]}: ${d2 * u2}px;padding-${f2[1]}: ${d2 * _2}px;margin-${f2[0]}: ${d2 * h}px;margin-${f2[1]}: ${d2 * p}px;border-${f2[0]}-width: ${d2 * m2}px;border-${f2[1]}-width: ${d2 * y2}px;` };\n}\nfunction tt(t, { delay: e = 0, duration: i = 400, easing: n = $, start: o2 = 0, opacity: r = 0 } = {}) {\n  let l2 = getComputedStyle(t), s = +l2.opacity, a2 = l2.transform === \"none\" ? \"\" : l2.transform, f2 = 1 - o2, c2 = s * (1 - r);\n  return { delay: e, duration: i, easing: n, css: (u2, _2) => `\n\t\t\ttransform: ${a2} scale(${1 - f2 * _2});\n\t\t\topacity: ${s - c2 * _2}\n\t\t` };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/animation.ts\nvar DEFAULT_ANIMATION_DURATION = 300;\nvar DEFAULT_ANIMATION_DELAY = 0;\nfunction makeAnimationMounter(animator) {\n  let element = null;\n  const { attach } = makeElementUser((e) => element = e);\n  function start() {\n    if (!element)\n      throw new Error(\"Animation cannot be started\");\n    const actionable = animator(element);\n    const duration = actionable.duration ?? DEFAULT_ANIMATION_DURATION;\n    const delay2 = actionable.delay ?? DEFAULT_ANIMATION_DELAY;\n    const frames = buildKeyframes(actionable);\n    return element.animate(\n      frames,\n      { delay: delay2, duration }\n    );\n  }\n  return { attach, start };\n}\nfunction buildKeyframes(actionable) {\n  const duration = actionable.duration ?? DEFAULT_ANIMATION_DURATION;\n  const framesPerSecond = actionable.fps ?? 60;\n  const millisecondsPerFrame = Math.floor(1e3 / framesPerSecond);\n  const framesCount = Math.ceil(duration / millisecondsPerFrame);\n  const frames = [];\n  for (let i = 0; i < framesCount; i++) {\n    const t = i / (framesCount - 1);\n    const frame = actionable.frame(t);\n    frames.push(frame);\n  }\n  return frames;\n}\nfunction parseCss(css) {\n  const lines = css.split(\";\").map((line) => line.trim());\n  const style = {};\n  for (const line of lines) {\n    const [key, value] = line.split(\":\");\n    if (!value)\n      throw new Error(`Invalid css. Expected a colon on line: ${line}`);\n    style[key.trim()] = value.trim();\n  }\n  return style;\n}\nfunction transConfToAction(transConf) {\n  return {\n    delay: transConf.delay,\n    duration: transConf.duration,\n    frame(rawT) {\n      const t = transConf.easing ? transConf.easing(rawT) : rawT;\n      if (!transConf.css)\n        throw new Error(\"`css` must be specified on the transition config\");\n      const css = transConf.css(t, 1 - t);\n      return parseCss(css);\n    }\n  };\n}\nfunction makeBlurAnimator(params) {\n  return (node) => transConfToAction(J(node, params));\n}\nfunction makeScaleAnimator(params) {\n  return (node) => transConfToAction(tt(node, params));\n}\nfunction makeSlideAnimator(params) {\n  return (node) => transConfToAction(Z(node, params));\n}\nfunction makeFlyAnimator(params) {\n  return (node) => transConfToAction(Q(node, params));\n}\nfunction makeFadeAnimator(params) {\n  return (node) => transConfToAction(K(node, params));\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/components/Transition.ts\nfunction Transition(props) {\n  const { $: $3, render: render2, use } = makeComponent();\n  const inMounter = props.in ? use(makeAnimationMounter(props.in)) : null;\n  const outMounter = props.out ? use(makeAnimationMounter(props.out)) : null;\n  use(\n    new LifecycleListeners({\n      onMounted() {\n        inMounter?.start();\n      },\n      async onDestroy() {\n        if (!outMounter)\n          return;\n        const animation = outMounter.start();\n        animation.reverse();\n        await animation.finished;\n      }\n    })\n  );\n  render2(props.child);\n  return { $: $3 };\n}\n\n// resolve:https://esm.sh/svelte@3.59.1/easing\nvar easing_exports = {};\n__export(easing_exports, {\n  backIn: () => k,\n  backInOut: () => E2,\n  backOut: () => M,\n  bounceIn: () => S2,\n  bounceInOut: () => O2,\n  bounceOut: () => c,\n  circIn: () => A2,\n  circInOut: () => I2,\n  circOut: () => D,\n  cubicIn: () => T,\n  cubicInOut: () => C2,\n  cubicOut: () => N2,\n  elasticIn: () => q,\n  elasticInOut: () => j,\n  elasticOut: () => P2,\n  expoIn: () => R2,\n  expoInOut: () => L2,\n  expoOut: () => B2,\n  linear: () => m,\n  quadIn: () => W,\n  quadInOut: () => z2,\n  quadOut: () => H,\n  quartIn: () => X,\n  quartInOut: () => G,\n  quartOut: () => Y,\n  quintIn: () => V,\n  quintInOut: () => U,\n  quintOut: () => J2,\n  sineIn: () => Q2,\n  sineInOut: () => K2,\n  sineOut: () => Z2\n});\n\n// resolve:https://esm.sh/stable/svelte@3.59.1/deno/easing.js\nvar __global$2 = globalThis || (typeof window !== \"undefined\" ? window : self);\nfunction u() {\n}\nvar m = (t) => t;\nfunction f(t) {\n  return t();\n}\nfunction d(t) {\n  t.forEach(f);\n}\nfunction l(t) {\n  return typeof t == \"function\";\n}\nfunction y(t) {\n  return Object.keys(t).length === 0;\n}\nvar _ = typeof document < \"u\" ? window : typeof globalThis < \"u\" ? globalThis : __global$2;\nvar o = class {\n  constructor(e) {\n    this.options = e, this._listeners = \"WeakMap\" in _ ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(e, n) {\n    return this._listeners.set(e, n), this._getObserver().observe(e, this.options), () => {\n      this._listeners.delete(e), this._observer.unobserve(e);\n    };\n  }\n  _getObserver() {\n    var e;\n    return (e = this._observer) !== null && e !== void 0 ? e : this._observer = new ResizeObserver((n) => {\n      var i;\n      for (let r of n)\n        o.entries.set(r.target, r), (i = this._listeners.get(r.target)) === null || i === void 0 || i(r);\n    });\n  }\n};\no.entries = \"WeakMap\" in _ ? /* @__PURE__ */ new WeakMap() : void 0;\nvar a = [];\nfunction b2(t) {\n  let e = [], n = [];\n  a.forEach((i) => t.indexOf(i) === -1 ? e.push(i) : n.push(i)), n.forEach((i) => i()), a = e;\n}\nvar g = [\"allowfullscreen\", \"allowpaymentrequest\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"defer\", \"disabled\", \"formnovalidate\", \"hidden\", \"inert\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"selected\"];\nvar F = /* @__PURE__ */ new Set([...g]);\nfunction w2(t, e) {\n  let n = t.$$;\n  n.fragment !== null && (b2(n.after_update), d(n.on_destroy), n.fragment && n.fragment.d(e), n.on_destroy = n.fragment = null, n.ctx = []);\n}\nvar $2;\ntypeof HTMLElement == \"function\" && ($2 = class extends HTMLElement {\n  constructor() {\n    super(), this.attachShadow({ mode: \"open\" });\n  }\n  connectedCallback() {\n    let { on_mount: t } = this.$$;\n    this.$$.on_disconnect = t.map(f).filter(l);\n    for (let e in this.$$.slotted)\n      this.appendChild(this.$$.slotted[e]);\n  }\n  attributeChangedCallback(t, e, n) {\n    this[t] = n;\n  }\n  disconnectedCallback() {\n    d(this.$$.on_disconnect);\n  }\n  $destroy() {\n    w2(this, 1), this.$destroy = u;\n  }\n  $on(t, e) {\n    if (!l(e))\n      return u;\n    let n = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);\n    return n.push(e), () => {\n      let i = n.indexOf(e);\n      i !== -1 && n.splice(i, 1);\n    };\n  }\n  $set(t) {\n    this.$$set && !y(t) && (this.$$.skip_bound = true, this.$$set(t), this.$$.skip_bound = false);\n  }\n});\nfunction E2(t) {\n  let e = 2.5949095;\n  return (t *= 2) < 1 ? 0.5 * (t * t * ((e + 1) * t - e)) : 0.5 * ((t -= 2) * t * ((e + 1) * t + e) + 2);\n}\nfunction k(t) {\n  return t * t * ((1.70158 + 1) * t - 1.70158);\n}\nfunction M(t) {\n  return --t * t * ((1.70158 + 1) * t + 1.70158) + 1;\n}\nfunction c(t) {\n  let e = 0.36363636363636365, n = 8 / 11, i = 9 / 10, r = 4356 / 361, h = 35442 / 1805, p = 16061 / 1805, s = t * t;\n  return t < e ? 7.5625 * s : t < n ? 9.075 * s - 9.9 * t + 3.4 : t < i ? r * s - h * t + p : 10.8 * t * t - 20.52 * t + 10.72;\n}\nfunction O2(t) {\n  return t < 0.5 ? 0.5 * (1 - c(1 - t * 2)) : 0.5 * c(t * 2 - 1) + 0.5;\n}\nfunction S2(t) {\n  return 1 - c(1 - t);\n}\nfunction I2(t) {\n  return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n}\nfunction A2(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\nfunction D(t) {\n  return Math.sqrt(1 - --t * t);\n}\nfunction C2(t) {\n  return t < 0.5 ? 4 * t * t * t : 0.5 * Math.pow(2 * t - 2, 3) + 1;\n}\nfunction T(t) {\n  return t * t * t;\n}\nfunction N2(t) {\n  let e = t - 1;\n  return e * e * e + 1;\n}\nfunction j(t) {\n  return t < 0.5 ? 0.5 * Math.sin(13 * Math.PI / 2 * 2 * t) * Math.pow(2, 10 * (2 * t - 1)) : 0.5 * Math.sin(-13 * Math.PI / 2 * (2 * t - 1 + 1)) * Math.pow(2, -10 * (2 * t - 1)) + 1;\n}\nfunction q(t) {\n  return Math.sin(13 * t * Math.PI / 2) * Math.pow(2, 10 * (t - 1));\n}\nfunction P2(t) {\n  return Math.sin(-13 * (t + 1) * Math.PI / 2) * Math.pow(2, -10 * t) + 1;\n}\nfunction L2(t) {\n  return t === 0 || t === 1 ? t : t < 0.5 ? 0.5 * Math.pow(2, 20 * t - 10) : -0.5 * Math.pow(2, 10 - t * 20) + 1;\n}\nfunction R2(t) {\n  return t === 0 ? t : Math.pow(2, 10 * (t - 1));\n}\nfunction B2(t) {\n  return t === 1 ? t : 1 - Math.pow(2, -10 * t);\n}\nfunction z2(t) {\n  return t /= 0.5, t < 1 ? 0.5 * t * t : (t--, -0.5 * (t * (t - 2) - 1));\n}\nfunction W(t) {\n  return t * t;\n}\nfunction H(t) {\n  return -t * (t - 2);\n}\nfunction G(t) {\n  return t < 0.5 ? 8 * Math.pow(t, 4) : -8 * Math.pow(t - 1, 4) + 1;\n}\nfunction X(t) {\n  return Math.pow(t, 4);\n}\nfunction Y(t) {\n  return Math.pow(t - 1, 3) * (1 - t) + 1;\n}\nfunction U(t) {\n  return (t *= 2) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2);\n}\nfunction V(t) {\n  return t * t * t * t * t;\n}\nfunction J2(t) {\n  return --t * t * t * t * t + 1;\n}\nfunction K2(t) {\n  return -0.5 * (Math.cos(Math.PI * t) - 1);\n}\nfunction Q2(t) {\n  let e = Math.cos(t * Math.PI * 0.5);\n  return Math.abs(e) < 1e-14 ? 1 : 1 - e;\n}\nfunction Z2(t) {\n  return Math.sin(t * Math.PI / 2);\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/livereload.ts\nvar wasDisconnected = false;\nfunction connect() {\n  const socket = new WebSocket(`ws://${location.host}/livereload.ws`);\n  if (wasDisconnected) {\n    socket.onopen = () => location.reload();\n  }\n  socket.onclose = () => {\n    console.log(\"Livereload socket, closed. Reconnecting in 1s\");\n    wasDisconnected = true;\n    setTimeout(connect, 100);\n  };\n}\nif (location.hostname === \"localhost\")\n  connect();\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/reset.ts\nvar resetCss = `\n\n:root {\n\tfont-size: 16px;\n}\n\nhtml, body {\n\theight: 100%;\n}\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n\tfont-family: inherit;\n\tfont-size: 100%;\n\tmargin: 0;\n\tpadding: 0;\n\tline-height: inherit;\n\tcolor: inherit;\n}\nsub,\nsup {\n\tfont-size: 75%;\n\tline-height: 0;\n\tposition: relative;\n\tvertical-align: baseline;\n}\nhtml {\n\tline-height: 1.5;\n\t-webkit-text-size-adjust: 100%;\n\tfont-family: 'Source Sans Pro', sans-serif, sans-serif;\n}\ntable {\n\ttext-indent: 0;\n\tborder-color: inherit;\n\tborder-collapse: collapse;\n}\nhr {\n\theight: 0;\n\tcolor: inherit;\n\tborder-top-width: 1px;\n}\ninput::placeholder,\ntextarea::placeholder {\n\topacity: 1;\n\tcolor: #a1a1aa;\n}\n::-webkit-file-upload-button {\n\t-webkit-appearance: button;\n\tfont: inherit;\n}\nbutton {\n\tbackground-color: transparent;\n\tbackground-image: none;\n}\nbody {\n\tfont-family: inherit;\n\tline-height: inherit;\n}\n*,\n::before,\n::after {\n\tbox-sizing: border-box;\n\tborder: 0 solid currentColor;\n}\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n\tfont-size: inherit;\n\tfont-weight: inherit;\n}\na {\n\tcolor: inherit;\n\t-webkit-text-decoration: inherit;\n\ttext-decoration: inherit;\n}\n::-moz-focus-inner {\n\tborder-style: none;\n\tpadding: 0;\n}\n[type='search'] {\n\t-webkit-appearance: textfield;\n\toutline-offset: -2px;\n}\npre,\ncode,\nkbd,\nsamp {\n\tfont-family: Cousine, monospace, monospace;\n\tfont-size: 1em;\n}\nimg,\nsvg,\nvideo,\ncanvas,\naudio,\niframe,\nembed,\nobject {\n\tdisplay: block;\n\tvertical-align: middle;\n}\nimg,\nvideo {\n\tmax-width: 100%;\n\theight: auto;\n}\nbody,\nblockquote,\ndl,\ndd,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\nhr,\nfigure,\np,\npre,\nfieldset,\nol,\nul {\n\tmargin: 0;\n}\nbutton:focus {\n\toutline: 1px dotted;\n\toutline: 5px auto -webkit-focus-ring-color;\n}\nfieldset,\nol,\nul,\nlegend {\n\tpadding: 0;\n}\ntextarea {\n\tresize: vertical;\n}\nbutton,\n[role='button'] {\n\tcursor: pointer;\n}\n:-moz-focusring {\n\toutline: 1px dotted ButtonText;\n}\n::-webkit-inner-spin-button,\n::-webkit-outer-spin-button {\n\theight: auto;\n}\nsummary {\n\tdisplay: list-item;\n}\n:root {\n\t-moz-tab-size: 4;\n\ttab-size: 4;\n}\nol,\nul {\n\tlist-style: none;\n}\nimg {\n\tborder-style: solid;\n}\nbutton,\nselect {\n\ttext-transform: none;\n}\n:-moz-ui-invalid {\n\tbox-shadow: none;\n}\nprogress {\n\tvertical-align: baseline;\n}\nabbr[title] {\n\t-webkit-text-decoration: underline dotted;\n\ttext-decoration: underline dotted;\n}\nb,\nstrong {\n\tfont-weight: bolder;\n}\nsub {\n\tbottom: -0.25em;\n}\nsup {\n\ttop: -0.5em;\n}\nbutton,\n[type='button'],\n[type='reset'],\n[type='submit'] {\n\t-webkit-appearance: button;\n}\n::-webkit-search-decoration {\n\t-webkit-appearance: none;\n}\n\n`;\nfunction reset() {\n  const style = document.createElement(\"style\");\n  style.textContent = resetCss;\n  document.head.appendChild(style);\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/render.ts\nfunction render(component, container) {\n  reset();\n  const element = component.$.mount();\n  container.appendChild(element);\n  component.$.mounted();\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/ui/theme.ts\nvar darkerBlue = makeRgb(0, 95, 184);\nvar lighterBlue = makeRgb(0, 120, 212);\nvar darkerTeal = makeRgb(15, 135, 135);\nvar lighterTeal = makeRgb(26, 190, 189);\nvar dark = makeRgb(24, 24, 24);\nvar light = makeRgb(250, 250, 250);\nvar error = makeRgb(253, 97, 97);\nvar success = makeRgb(49, 215, 0);\nvar darkTheme = {\n  primary: lighterBlue,\n  onPrimary: light,\n  primaryVariant: darkerBlue,\n  onPrimaryVariant: light,\n  secondary: lighterTeal,\n  onSecondary: light,\n  secondaryVariant: darkerTeal,\n  onSecondaryVariant: light,\n  background: dark,\n  foreground: light,\n  error,\n  success\n};\nvar lightTheme = {\n  primary: darkerBlue,\n  onPrimary: light,\n  primaryVariant: lighterBlue,\n  onPrimaryVariant: light,\n  secondary: darkerTeal,\n  onSecondary: light,\n  secondaryVariant: lighterTeal,\n  onSecondaryVariant: light,\n  background: light,\n  foreground: dark,\n  error,\n  success\n};\n\n// resolve:https://deno.land/x/storable@1.1.1/mod.ts\nfunction makeStorable(value, options = {}) {\n  const subscribers = [];\n  function get() {\n    return value;\n  }\n  function set(newVal) {\n    value = newVal;\n    subscribers.forEach((listener) => listener(value, false));\n  }\n  function subscribe(listener) {\n    if (!options.noImmediateUpdate)\n      listener(value, true);\n    subscribers.push(listener);\n    return () => {\n      const index = subscribers.indexOf(listener);\n      if (index === -1)\n        return;\n      subscribers.splice(index, 1);\n    };\n  }\n  return {\n    get,\n    set,\n    subscribe\n  };\n}\n\n// resolve:https://deno.land/std@0.186.0/async/mod.ts\nvar mod_exports2 = {};\n__export(mod_exports2, {\n  DeadlineError: () => DeadlineError,\n  ERROR_WHILE_MAPPING_MESSAGE: () => ERROR_WHILE_MAPPING_MESSAGE,\n  MuxAsyncIterator: () => MuxAsyncIterator,\n  RetryError: () => RetryError,\n  abortable: () => abortable,\n  abortableAsyncIterable: () => abortableAsyncIterable,\n  abortablePromise: () => abortablePromise,\n  deadline: () => deadline,\n  debounce: () => debounce,\n  deferred: () => deferred,\n  delay: () => delay,\n  pooledMap: () => pooledMap,\n  retry: () => retry,\n  tee: () => tee\n});\n\n// resolve:https://deno.land/std@0.186.0/async/deferred.ts\nfunction deferred() {\n  let methods;\n  let state = \"pending\";\n  const promise = new Promise((resolve, reject) => {\n    methods = {\n      async resolve(value) {\n        await value;\n        state = \"fulfilled\";\n        resolve(value);\n      },\n      reject(reason) {\n        state = \"rejected\";\n        reject(reason);\n      }\n    };\n  });\n  Object.defineProperty(promise, \"state\", { get: () => state });\n  return Object.assign(promise, methods);\n}\n\n// resolve:https://deno.land/std@0.186.0/async/abortable.ts\nfunction abortable(p, signal) {\n  if (p instanceof Promise) {\n    return abortablePromise(p, signal);\n  } else {\n    return abortableAsyncIterable(p, signal);\n  }\n}\nfunction abortablePromise(p, signal) {\n  if (signal.aborted) {\n    return Promise.reject(createAbortError(signal.reason));\n  }\n  const waiter = deferred();\n  const abort = () => waiter.reject(createAbortError(signal.reason));\n  signal.addEventListener(\"abort\", abort, { once: true });\n  return Promise.race([\n    waiter,\n    p.finally(() => {\n      signal.removeEventListener(\"abort\", abort);\n    })\n  ]);\n}\nasync function* abortableAsyncIterable(p, signal) {\n  if (signal.aborted) {\n    throw createAbortError(signal.reason);\n  }\n  const waiter = deferred();\n  const abort = () => waiter.reject(createAbortError(signal.reason));\n  signal.addEventListener(\"abort\", abort, { once: true });\n  const it = p[Symbol.asyncIterator]();\n  while (true) {\n    const { done, value } = await Promise.race([waiter, it.next()]);\n    if (done) {\n      signal.removeEventListener(\"abort\", abort);\n      return;\n    }\n    yield value;\n  }\n}\nfunction createAbortError(reason) {\n  return new DOMException(\n    reason ? `Aborted: ${reason}` : \"Aborted\",\n    \"AbortError\"\n  );\n}\n\n// resolve:https://deno.land/std@0.186.0/async/delay.ts\nfunction delay(ms, options = {}) {\n  const { signal, persistent } = options;\n  if (signal?.aborted) {\n    return Promise.reject(new DOMException(\"Delay was aborted.\", \"AbortError\"));\n  }\n  return new Promise((resolve, reject) => {\n    const abort = () => {\n      clearTimeout(i);\n      reject(new DOMException(\"Delay was aborted.\", \"AbortError\"));\n    };\n    const done = () => {\n      signal?.removeEventListener(\"abort\", abort);\n      resolve();\n    };\n    const i = setTimeout(done, ms);\n    signal?.addEventListener(\"abort\", abort, { once: true });\n    if (persistent === false) {\n      try {\n        Deno.unrefTimer(i);\n      } catch (error2) {\n        if (!(error2 instanceof ReferenceError)) {\n          throw error2;\n        }\n        console.error(\"`persistent` option is only available in Deno\");\n      }\n    }\n  });\n}\n\n// resolve:https://deno.land/std@0.186.0/async/deadline.ts\nvar DeadlineError = class extends Error {\n  constructor() {\n    super(\"Deadline\");\n    this.name = this.constructor.name;\n  }\n};\nfunction deadline(p, ms, options = {}) {\n  const controller = new AbortController();\n  const { signal } = options;\n  if (signal?.aborted) {\n    return Promise.reject(new DeadlineError());\n  }\n  signal?.addEventListener(\"abort\", () => controller.abort(signal.reason));\n  const d2 = delay(ms, { signal: controller.signal }).catch(() => {\n  }).then(() => Promise.reject(new DeadlineError()));\n  return Promise.race([p.finally(() => controller.abort()), d2]);\n}\n\n// resolve:https://deno.land/std@0.186.0/async/debounce.ts\nfunction debounce(fn, wait) {\n  let timeout = null;\n  let flush = null;\n  const debounced = (...args) => {\n    debounced.clear();\n    flush = () => {\n      debounced.clear();\n      fn.call(debounced, ...args);\n    };\n    timeout = setTimeout(flush, wait);\n  };\n  debounced.clear = () => {\n    if (typeof timeout === \"number\") {\n      clearTimeout(timeout);\n      timeout = null;\n      flush = null;\n    }\n  };\n  debounced.flush = () => {\n    flush?.();\n  };\n  Object.defineProperty(debounced, \"pending\", {\n    get: () => typeof timeout === \"number\"\n  });\n  return debounced;\n}\n\n// resolve:https://deno.land/std@0.186.0/async/mux_async_iterator.ts\nvar MuxAsyncIterator = class {\n  #iteratorCount = 0;\n  #yields = [];\n  #throws = [];\n  #signal = deferred();\n  add(iterable) {\n    ++this.#iteratorCount;\n    this.#callIteratorNext(iterable[Symbol.asyncIterator]());\n  }\n  async #callIteratorNext(iterator) {\n    try {\n      const { value, done } = await iterator.next();\n      if (done) {\n        --this.#iteratorCount;\n      } else {\n        this.#yields.push({ iterator, value });\n      }\n    } catch (e) {\n      this.#throws.push(e);\n    }\n    this.#signal.resolve();\n  }\n  async *iterate() {\n    while (this.#iteratorCount > 0) {\n      await this.#signal;\n      for (let i = 0; i < this.#yields.length; i++) {\n        const { iterator, value } = this.#yields[i];\n        yield value;\n        this.#callIteratorNext(iterator);\n      }\n      if (this.#throws.length) {\n        for (const e of this.#throws) {\n          throw e;\n        }\n        this.#throws.length = 0;\n      }\n      this.#yields.length = 0;\n      this.#signal = deferred();\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this.iterate();\n  }\n};\n\n// resolve:https://deno.land/std@0.186.0/async/pool.ts\nvar ERROR_WHILE_MAPPING_MESSAGE = \"Threw while mapping.\";\nfunction pooledMap(poolLimit, array, iteratorFn) {\n  const res = new TransformStream({\n    async transform(p, controller) {\n      try {\n        const s = await p;\n        controller.enqueue(s);\n      } catch (e) {\n        if (e instanceof AggregateError && e.message == ERROR_WHILE_MAPPING_MESSAGE) {\n          controller.error(e);\n        }\n      }\n    }\n  });\n  (async () => {\n    const writer = res.writable.getWriter();\n    const executing = [];\n    try {\n      for await (const item of array) {\n        const p = Promise.resolve().then(() => iteratorFn(item));\n        writer.write(p);\n        const e = p.then(\n          () => executing.splice(executing.indexOf(e), 1)\n        );\n        executing.push(e);\n        if (executing.length >= poolLimit) {\n          await Promise.race(executing);\n        }\n      }\n      await Promise.all(executing);\n      writer.close();\n    } catch {\n      const errors = [];\n      for (const result of await Promise.allSettled(executing)) {\n        if (result.status == \"rejected\") {\n          errors.push(result.reason);\n        }\n      }\n      writer.write(Promise.reject(\n        new AggregateError(errors, ERROR_WHILE_MAPPING_MESSAGE)\n      )).catch(() => {\n      });\n    }\n  })();\n  return Symbol.asyncIterator in res.readable && typeof res.readable[Symbol.asyncIterator] === \"function\" ? res.readable[Symbol.asyncIterator]() : async function* () {\n    const reader = res.readable.getReader();\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done)\n        break;\n      yield value;\n    }\n    reader.releaseLock();\n  }();\n}\n\n// resolve:https://deno.land/std@0.186.0/async/tee.ts\nvar Queue = class {\n  #source;\n  #queue;\n  constructor(iterable) {\n    this.#source = iterable[Symbol.asyncIterator]();\n    this.#queue = {\n      value: void 0,\n      next: void 0\n    };\n    this.head = this.#queue;\n    this.done = false;\n  }\n  async next() {\n    const result = await this.#source.next();\n    if (!result.done) {\n      const nextNode = {\n        value: result.value,\n        next: void 0\n      };\n      this.#queue.next = nextNode;\n      this.#queue = nextNode;\n    } else {\n      this.done = true;\n    }\n  }\n};\nfunction tee(iterable, n = 2) {\n  const queue = new Queue(iterable);\n  async function* generator() {\n    let buffer = queue.head;\n    while (true) {\n      if (buffer.next) {\n        buffer = buffer.next;\n        yield buffer.value;\n      } else if (queue.done) {\n        return;\n      } else {\n        await queue.next();\n      }\n    }\n  }\n  const branches = Array.from({ length: n }).map(\n    () => generator()\n  );\n  return branches;\n}\n\n// resolve:https://deno.land/std@0.186.0/async/retry.ts\nvar RetryError = class extends Error {\n  constructor(cause, count) {\n    super(`Exceeded max retry count (${count})`);\n    this.name = \"RetryError\";\n    this.cause = cause;\n  }\n};\nvar defaultRetryOptions = {\n  multiplier: 2,\n  maxTimeout: 6e4,\n  maxAttempts: 5,\n  minTimeout: 1e3\n};\nasync function retry(fn, opts) {\n  const options = {\n    ...defaultRetryOptions,\n    ...opts\n  };\n  if (options.maxTimeout >= 0 && options.minTimeout > options.maxTimeout) {\n    throw new RangeError(\"minTimeout is greater than maxTimeout\");\n  }\n  let timeout = options.minTimeout;\n  let error2;\n  for (let i = 0; i < options.maxAttempts; i++) {\n    try {\n      return await fn();\n    } catch (err) {\n      await new Promise((r) => setTimeout(r, timeout));\n      timeout *= options.multiplier;\n      timeout = Math.max(timeout, options.minTimeout);\n      if (options.maxTimeout >= 0) {\n        timeout = Math.min(timeout, options.maxTimeout);\n      }\n      error2 = err;\n    }\n  }\n  throw new RetryError(error2, options.maxAttempts);\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/app/globals.ts\nvar theme = makeStorable(mod_exports.darkTheme);\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/app/background.ts\nfunction ScreenBackground(props) {\n  const { $: $3, render: render2 } = mod_exports.makeComponent();\n  render2(\n    mod_exports.Stack({\n      children: [\n        mod_exports.StackItem({\n          inset: 0,\n          child: mod_exports.Image(props.imageUrl, { fit: \"cover\", position: \"center\" })\n        }),\n        mod_exports.StackItem({\n          inset: 0,\n          child: mod_exports.Container({\n            backdropFilters: [\"blur(50px)\"],\n            color: mod_exports.setAlpha(theme.get().background, 0.3)\n          })\n        })\n      ]\n    })\n  );\n  return { $: $3 };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/app/grid/Cell.ts\nfunction Cell(props) {\n  const { $: $3, render: render2 } = mod_exports.makeComponent();\n  const sizedBox = mod_exports.SizedBox({\n    width: props.width,\n    height: props.height,\n    child: mod_exports.Container({\n      borderRadius: 10,\n      borderWidth: 3,\n      borderColor: mod_exports.setAlpha(theme.get().foreground, 0.05),\n      borderStyle: \"dashed\"\n    })\n  });\n  const stackItem = mod_exports.StackItem({ child: sizedBox, top: props.posY, left: props.posX });\n  render2(stackItem);\n  function setPosY(posY) {\n    stackItem.setTop(posY);\n  }\n  function setPosX(posX) {\n    stackItem.setLeft(posX);\n  }\n  function setWidth(width) {\n    sizedBox.setWidth(width);\n  }\n  function setHeight(height) {\n    sizedBox.setHeight(height);\n  }\n  return { $: $3, setPosX, setPosY, setWidth, setHeight };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/app/grid/layout.ts\nfunction inferGridLayout(width, height, options = {}) {\n  const minPaddingX = options.minPaddingX ?? 15;\n  const minPaddingY = options.minPaddingY ?? 30;\n  const minCellWidth = options.minCellWidth ?? 60;\n  const minCellHeight = options.minCellHeight ?? 60;\n  const spaceX = width - minPaddingX;\n  const spaceY = height - minPaddingY;\n  const cellSpaceX = minCellWidth + minPaddingX;\n  const cellSpaceY = minCellHeight + minPaddingY;\n  const cellCountX = Math.floor(spaceX / cellSpaceX);\n  const cellCountY = Math.floor(spaceY / cellSpaceY);\n  const extraSpaceX = spaceX % cellSpaceX;\n  const extraSpaceY = spaceY % cellSpaceY;\n  const expansionSpaceX = extraSpaceX;\n  const expansionSpaceY = extraSpaceY;\n  const addedPaddingSizeX = expansionSpaceX / (cellCountX + 1);\n  const addedPaddingSizeY = expansionSpaceY / (cellCountY + 1);\n  const cellWidth = minCellWidth;\n  const cellHeight = minCellHeight;\n  const paddingXSize = minPaddingX + addedPaddingSizeX;\n  const paddingYSize = minPaddingY + addedPaddingSizeY;\n  return { cellCountX, cellCountY, cellWidth, cellHeight, paddingXSize, paddingYSize };\n}\nfunction getPosition(params) {\n  const posY = params.layout.paddingYSize + (params.layout.cellHeight + params.layout.paddingYSize) * params.y;\n  const posX = params.layout.paddingXSize + (params.layout.cellWidth + params.layout.paddingXSize) * params.x;\n  const cellSpanX = params.layout.cellWidth * params.spanX;\n  const cellSpanY = params.layout.cellHeight * params.spanY;\n  const paddingSpanX = params.layout.paddingXSize * (params.spanX - 1);\n  const paddingSpanY = params.layout.paddingYSize * (params.spanY - 1);\n  return {\n    posX,\n    posY,\n    width: cellSpanX + paddingSpanX,\n    height: cellSpanY + paddingSpanY\n  };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/app/grid/Cells.ts\nfunction Cells(props) {\n  const { $: $3, render: render2 } = mod_exports.makeComponent();\n  let layout = props.layout;\n  const cellsStack = mod_exports.Stack({ children: [] });\n  render2(cellsStack);\n  updateCellsStack();\n  function updateCellsStack() {\n    let cellIndex = 0;\n    for (let y2 = 0; y2 < layout.cellCountY; y2++) {\n      for (let x2 = 0; x2 < layout.cellCountX; x2++) {\n        const physicalCell = getPosition({ layout, x: x2, y: y2, spanX: 1, spanY: 1 });\n        const cell = cellsStack.children[cellIndex];\n        if (cell) {\n          cell.setPosY(physicalCell.posY);\n          cell.setPosX(physicalCell.posX);\n          cell.setHeight(layout.cellHeight);\n          cell.setWidth(layout.cellWidth);\n        } else {\n          cellsStack.push(\n            Cell({\n              height: layout.cellHeight,\n              width: layout.cellWidth,\n              posX: physicalCell.posX,\n              posY: physicalCell.posY\n            })\n          );\n        }\n        cellIndex++;\n      }\n    }\n    const updatedCellsInGraphCount = cellIndex + 1;\n    while (updatedCellsInGraphCount < cellsStack.children.length) {\n      cellsStack.removeChild(updatedCellsInGraphCount);\n    }\n  }\n  function updateLayout(newLayout) {\n    layout = newLayout;\n    updateCellsStack();\n  }\n  return { $: $3, updateLayout };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/app/SkeletonLoader.ts\nfunction SkeletonLoader(props = {}) {\n  const { $: $3, render: render2, use } = mod_exports.makeComponent();\n  let didDestroy = false;\n  const mounter = use(mod_exports.makeAnimationMounter(makeSlidingPulseAnimation(props)));\n  use(\n    new mod_exports.LifecycleListeners({\n      async onMounted() {\n        const animation = mounter.start();\n        while (!didDestroy) {\n          await animation.finished;\n          animation.play();\n        }\n      },\n      onDestroy() {\n        didDestroy = true;\n      }\n    })\n  );\n  render2(mod_exports.Block());\n  return { $: $3 };\n}\nfunction makeSlidingPulseAnimation(params = {}) {\n  return (node) => {\n    const computed = getComputedStyle(node);\n    const baseColor = params.useBackgroundColor ? theme.get().background : theme.get().foreground;\n    const first = `rgba(0,0,0,0) 0%`;\n    const last = `rgba(0,0,0,0) 100%`;\n    const oneThird = 1 / 3;\n    const twoThirds = 2 / 3;\n    const wrap = (internals) => `${computed.backgroundImage}, linear-gradient(90deg, ${first}, ${internals}, ${last})`;\n    return {\n      delay: params.delay,\n      duration: params.duration ?? 1e3,\n      frame(t) {\n        const progressT = t < oneThird ? 0 : t > twoThirds ? 1 : mod_exports.easing.quartOut((t - oneThird) * 3);\n        const opacityT = t <= oneThird ? t * 3 : t >= twoThirds ? 1 - (t - twoThirds) * 3 : 1;\n        return { background: wrap(`${mod_exports.stringifyColor(mod_exports.setAlpha(baseColor, opacityT * 0.05))} ${progressT * 100}%`) };\n      }\n    };\n  };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/app/widget.ts\nfunction getWidget(id) {\n  console.log(`pretending to get get the meta for widget ${id}`);\n  return {\n    label: `Widget ${id}`,\n    async getElement() {\n      console.log(`pretending to load html element for widget ${id}`);\n      await mod_exports2.delay(Math.random() * 1e4);\n      const component = mod_exports.Center({\n        child: mod_exports.Label(\"Hello, World!\", { color: theme.get().foreground })\n      });\n      const element = component.$.mount();\n      component.$.mounted();\n      return element;\n    }\n  };\n}\nfunction cleanupWidget(id) {\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/app/grid/Widget.ts\nfunction Widget(props) {\n  const { $: $3, render: render2, use } = mod_exports.makeComponent();\n  const widget = getWidget(props.id);\n  let destroyed = false;\n  use(\n    new mod_exports.LifecycleListeners({\n      onDestroy() {\n        cleanupWidget(props.id);\n        destroyed = true;\n      }\n    })\n  );\n  const loaderSwitch = mod_exports.SingleChildBlock({ child: buildSkeleton() });\n  const widgetSwitch = mod_exports.SingleChildBlock();\n  const sizedBox = mod_exports.SizedBox({\n    height: props.position.height,\n    width: props.position.width,\n    child: mod_exports.Container({\n      borderRadius: 10,\n      clip: true,\n      child: mod_exports.Stack({\n        children: [\n          mod_exports.StackItem({ inset: 0, child: loaderSwitch }),\n          mod_exports.StackItem({ inset: 0, child: widgetSwitch })\n        ]\n      })\n    })\n  });\n  const stackItem = mod_exports.StackItem({ child: sizedBox, top: props.position.posY, left: props.position.posX });\n  render2(stackItem);\n  widget.getElement().then((element) => {\n    if (destroyed)\n      return;\n    widgetSwitch.setChild(buildWidget(element));\n    loaderSwitch.setChild(null);\n  });\n  function buildWidget(element) {\n    return mod_exports.Transition({\n      in: mod_exports.makeFadeAnimator(),\n      child: mod_exports.Container({\n        color: theme.get().background,\n        child: mod_exports.RenderElement({ element })\n      })\n    });\n  }\n  function buildSkeleton() {\n    return mod_exports.Transition({\n      out: mod_exports.makeFadeAnimator({ delay: 300 }),\n      child: mod_exports.Container({\n        color: mod_exports.setAlpha(theme.get().background, 0.3),\n        child: SkeletonLoader()\n      })\n    });\n  }\n  function setPosition(position) {\n    sizedBox.setWidth(position.width);\n    sizedBox.setHeight(position.height);\n    stackItem.setTop(position.posY);\n    stackItem.setLeft(position.posX);\n  }\n  return { $: $3, id: props.id, setPosition };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/app/grid/Widgets.ts\nfunction Widgets(props) {\n  const { $: $3, render: render2 } = mod_exports.makeComponent();\n  let widgets = props.widgets;\n  let layout = props.layout;\n  const stack = mod_exports.Stack({ children: [] });\n  render2(stack);\n  updateWidgetsOnGrid();\n  function updateWidgetsOnGrid() {\n    console.log(widgets);\n    for (const widget of widgets) {\n      const physicalWidget = stack.children.find((child) => child.id === widget.id);\n      const position = getPosition({\n        layout,\n        spanX: widget.spanX,\n        spanY: widget.spanY,\n        x: widget.startCell.x,\n        y: widget.startCell.y\n      });\n      if (physicalWidget)\n        physicalWidget.setPosition(position);\n      else\n        stack.push(Widget({ id: widget.id, position }));\n    }\n    for (const physicalWidget of [...stack.children]) {\n      const widget = widgets.find((widget2) => widget2.id === physicalWidget.id);\n      if (widget)\n        continue;\n      const widgetIndex = stack.children.findIndex((w3) => w3.id === physicalWidget.id);\n      stack.removeChild(widgetIndex);\n    }\n  }\n  function update(newWidgets, newLayout) {\n    widgets = newWidgets;\n    layout = newLayout;\n    updateWidgetsOnGrid();\n  }\n  return { $: $3, update };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/app/grid/Grid.ts\nfunction Grid(props) {\n  const { $: $3, render: render2, use } = mod_exports.makeComponent();\n  let layout = null;\n  let cellsComponent = null;\n  const cellsSwitch = mod_exports.SingleChildBlock();\n  let widgetsComponent = null;\n  const widgetsSwitch = mod_exports.SingleChildBlock();\n  const dimensions = use(mod_exports.makeDimensionProvider());\n  use(\n    new mod_exports.LifecycleListeners({\n      onMounted() {\n        resetLayout();\n      }\n    })\n  );\n  render2(\n    mod_exports.Stack({\n      children: [\n        mod_exports.StackItem({ child: cellsSwitch, inset: 0 }),\n        mod_exports.StackItem({ child: widgetsSwitch, inset: 0 })\n      ]\n    })\n  );\n  function setCellsShowing(showing) {\n    if (!layout)\n      throw new Error(\"Cannot set the cells to be showing until the component has mounted\");\n    if (showing) {\n      cellsComponent = Cells({ layout });\n      cellsSwitch.setChild(cellsComponent);\n    } else {\n      cellsComponent = null;\n      cellsSwitch.setChild(null);\n    }\n  }\n  function resetLayout() {\n    layout = inferGridLayout(dimensions.getWidth(), dimensions.getHeight());\n    if (!widgetsComponent) {\n      widgetsComponent = Widgets({ layout, widgets: props.widgets });\n      widgetsSwitch.setChild(widgetsComponent);\n    }\n    if (cellsComponent)\n      cellsComponent.updateLayout(layout);\n  }\n  return { $: $3, setCellsShowing, resetLayout };\n}\n\n// resolve:file:///Users/elijah.mooring/Projects/learning/nested/app/main.ts\nvar BACKGROUND_IMG = \"https://images.unsplash.com/photo-1581790059834-8c317f59448a?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2071&q=80\";\nvar mainElement = document.createElement(\"div\");\nmainElement.style.top = \"0\";\nmainElement.style.right = \"0\";\nmainElement.style.left = \"0\";\nmainElement.style.bottom = \"0\";\nmainElement.style.position = \"absolute\";\ndocument.body.style.overflow = \"hidden\";\ndocument.body.appendChild(mainElement);\nmod_exports.render(\n  mod_exports.Stack({\n    children: [\n      mod_exports.StackItem({\n        inset: 0,\n        child: ScreenBackground({ imageUrl: BACKGROUND_IMG })\n      }),\n      mod_exports.StackItem({\n        inset: 0,\n        child: Grid({\n          widgets: [\n            {\n              id: \"23451\",\n              startCell: { x: 0, y: 0 },\n              spanX: 4,\n              spanY: 2\n            },\n            {\n              id: \"ha82uij\",\n              startCell: { x: 0, y: 2 },\n              spanX: 6,\n              spanY: 6\n            },\n            {\n              id: \"hja82js\",\n              startCell: { x: 4, y: 0 },\n              spanX: 1,\n              spanY: 1\n            }\n          ]\n        })\n      })\n    ]\n  }),\n  mainElement\n);\n\n\n})()"